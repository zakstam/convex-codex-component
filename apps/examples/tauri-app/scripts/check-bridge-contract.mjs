import assert from "node:assert/strict";
import { execFileSync } from "node:child_process";
import { existsSync, readFileSync, readdirSync } from "node:fs";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";

const here = dirname(fileURLToPath(import.meta.url));
const appRoot = join(here, "..");
const contractPath = join(appRoot, "bridge", "command-contract.json");

execFileSync("node", ["./scripts/generate-bridge-contract.mjs"], {
  cwd: appRoot,
  stdio: "inherit",
});

assert.equal(existsSync(contractPath), true, "Missing bridge/command-contract.json");
const contract = JSON.parse(readFileSync(contractPath, "utf8"));
const commands = Array.isArray(contract.commands) ? contract.commands : [];

const tauriBridgeSource = readFileSync(join(appRoot, "src", "lib", "tauriBridge.generated.ts"), "utf8");
const helperContractSource = readFileSync(
  join(appRoot, "src-node", "bridge-contract.generated.ts"),
  "utf8",
);
const nodeDispatchSource = readFileSync(
  join(appRoot, "src-node", "bridge-dispatch.generated.ts"),
  "utf8",
);
const rustContractSource = readFileSync(
  join(appRoot, "src-tauri", "src", "bridge_contract_generated.rs"),
  "utf8",
);
const rustDispatchSource = readFileSync(
  join(appRoot, "src-tauri", "src", "bridge_dispatch_generated.rs"),
  "utf8",
);
const rustInvokeHandlersSource = readFileSync(
  join(appRoot, "src-tauri", "src", "bridge_invoke_handlers_generated.rs"),
  "utf8",
);
const permissionsDir = join(appRoot, "src-tauri", "permissions", "autogenerated");

for (const command of commands) {
  if (typeof command.tauriCommand === "string") {
    assert.match(
      tauriBridgeSource,
      new RegExp(`invoke\\("${command.tauriCommand}"`),
      `Missing invoke wrapper for ${command.tauriCommand}`,
    );
    assert.match(
      rustContractSource,
      new RegExp(`"${command.tauriCommand}"`),
      `Missing Rust command constant for ${command.tauriCommand}`,
    );
    if (typeof command.helperType === "string") {
      assert.match(
        nodeDispatchSource,
        new RegExp(`"${command.tauriCommand}"\\s*:\\s*"${command.helperType}"`),
        `Missing node dispatch mapping for ${command.tauriCommand}`,
      );
      assert.match(
        rustDispatchSource,
        new RegExp(`"${command.tauriCommand}"\\s*=>\\s*Some\\("${command.helperType}"\\)`),
        `Missing rust dispatch mapping for ${command.tauriCommand}`,
      );
    }
    assert.match(
      rustInvokeHandlersSource,
      new RegExp(`\\b${command.tauriCommand}\\b`),
      `Missing invoke handler entry for ${command.tauriCommand}`,
    );
  }
  if (typeof command.helperType === "string") {
    assert.match(
      helperContractSource,
      new RegExp(`"${command.helperType}"`),
      `Missing helper command for ${command.helperType}`,
    );
  }
}

const expectedPermissionFiles = new Set(
  commands
    .filter((command) => command.permission === true && typeof command.tauriCommand === "string")
    .map((command) => `${command.tauriCommand}.toml`),
);
const actualPermissionFiles = readdirSync(permissionsDir).filter((name) => name.endsWith(".toml"));

for (const filename of expectedPermissionFiles) {
  assert.equal(
    actualPermissionFiles.includes(filename),
    true,
    `Missing permission file ${filename}`,
  );
}
