src/host/convexPresetMutations.ts:7:  ensureSession as ensureSessionHandler,
src/host/convexPreset.ts:283:  [K in keyof M as M[K]]: K;
src/host/convexPreset.ts:288: * If the public key appears as a value in the alias map, the corresponding
src/host/convexPreset.ts:369:      const typedDefinition = definition as RuntimeOwnedDefinitionWithActor<unknown>;
src/host/convexPreset.ts:381:  ) as unknown as RuntimeOwnedHostDefinitions["mutations"];
src/host/convexPreset.ts:385:      const typedDefinition = definition as RuntimeOwnedDefinitionWithActor<unknown>;
src/host/convexPreset.ts:397:  ) as unknown as RuntimeOwnedHostDefinitions["queries"];
src/host/convexPreset.ts:508:    mutations: pickedMutations as RuntimeOwnedHostDefinitions["mutations"],
src/host/convexPreset.ts:509:    queries: pickedQueries as RuntimeOwnedHostDefinitions["queries"],
src/host/convexPreset.ts:532:  const mutationWrapper = options.mutation as (definition: unknown) => unknown;
src/host/convexPreset.ts:533:  const queryWrapper = options.query as (definition: unknown) => unknown;
src/host/convexPreset.ts:540:  ) as WrappedDefinitionMap<RuntimeOwnedHostDefinitions["mutations"], typeof options.mutation>;
src/host/convexPreset.ts:547:  ) as WrappedDefinitionMap<RuntimeOwnedHostDefinitions["queries"], typeof options.query>;
src/host/convexPreset.ts:552:    mutations: publicMutationDefs as RuntimeOwnedHostDefinitions["mutations"],
src/host/convexPreset.ts:553:    queries: publicQueryDefs as RuntimeOwnedHostDefinitions["queries"],
src/react/useCodex.ts:66:    : ({ actor: ctx.actor, threadId } as never);
src/react/useCodex.ts:69:    : ({ actor: ctx.actor, threadId } as never);
src/react/CodexProvider.tsx:32:      actor: actor ?? ({} as Record<string, unknown>),
src/react/CodexProvider.tsx:33:      listThreadMessages: api.listThreadMessages as CodexMessagesQuery<unknown>,
src/react/CodexProvider.tsx:34:      threadSnapshotSafe: api.threadSnapshotSafe as CodexThreadStateQuery<unknown, CodexThreadActivityThreadState>,
src/component/threads.ts:580:          const parsed = JSON.parse(event.payloadJson) as { streamId?: unknown };
src/component/deletionUtils.ts:40:    const parsed = JSON.parse(deletedCountsJson) as unknown;
src/component/deletionUtils.ts:59:    const parsed = JSON.parse(deletedCountsJson) as unknown;
src/host/convexSlice.ts:333:  const record = value as Record<string, unknown>;
src/host/convexSlice.ts:345:  const streamStats = (state as { streamStats?: unknown[] | null }).streamStats;
src/host/convexSlice.ts:353:  const recentMessages = (state as { recentMessages?: DurableHistoryMessage[] | null }).recentMessages;
src/host/convexSlice.ts:361:  const allStreams = (state as { allStreams?: Array<{ streamId: string }> | null }).allStreams;
src/component/deletionCascade.ts:24:  await Promise.all(docs.map((doc) => ctx.db.delete(doc._id as never)));
src/host/runtimeHelpers.ts:37:  return typeof value === "object" && value !== null ? (value as Record<string, unknown>) : null;
src/host/runtimeCoreHandlers.ts:270:      const ro = typeof message.result === "object" && message.result !== null ? (message.result as Record<string, unknown>) : null;
src/host/runtimeCoreHandlers.ts:271:      const to = ro && typeof ro.turn === "object" && ro.turn !== null ? (ro.turn as Record<string, unknown>) : null;
src/host/runtimeCore.ts:35:  clearPendingServerRequestRetryTimer as clearRetryTimer,
src/host/runtimeCore.ts:37:  flushQueue as flushQueueHandler,
src/host/runtimeCore.ts:38:  handleBridgeEvent as bridgeEventHandler,
src/host/runtimeCore.ts:39:  handleBridgeGlobalMessage as bridgeGlobalHandler,
src/component/tokenUsage.ts:35:    // (for example runtime placeholder turn ids). Treat as best-effort.
src/host/wrapDefinitions.ts:21:  const mutationWrapper = wrap.mutation as (
src/host/wrapDefinitions.ts:24:  const queryWrapper = wrap.query as (
src/host/wrapDefinitions.ts:30:    mutationWrapper(definition as Defs["mutations"][keyof Defs["mutations"]]),
src/host/wrapDefinitions.ts:34:    queryWrapper(definition as Defs["queries"][keyof Defs["queries"]]),
src/host/wrapDefinitions.ts:39:    mutations: Object.fromEntries(mutationEntries) as WrappedDefinitionMap<Defs["mutations"], MutationWrap>,
src/host/wrapDefinitions.ts:40:    queries: Object.fromEntries(queryEntries) as WrappedDefinitionMap<Defs["queries"], QueryWrap>,
src/component/pagination.ts:18:    return JSON.parse(cursor) as T;
src/app-server/client.ts:56:  return { method, id, params } as RequestFor<M>;
src/react/dynamicTools.ts:43:  return typeof value === "object" && value !== null ? (value as Record<string, unknown>) : null;
src/react/dynamicTools.ts:48:    const parsed = JSON.parse(payloadJson) as unknown;
src/react/useCodexConversationController.ts:69:  const record = value as Record<string, unknown>;
src/react/useCodexReasoning.ts:16:  const paginated = usePaginatedQuery(query, args as PaginatedQueryArgs<Query> | "skip", {
src/react/queryArgs.ts:12:    return ["skip"] as OptionalRestArgsOrSkip<Query>;
src/react/queryArgs.ts:14:  return [args] as OptionalRestArgsOrSkip<Query>;
src/react/useCodexMessages.ts:15:  const paginated = usePaginatedQuery(query, args as PaginatedQueryArgs<Query> | "skip", {
src/protocol/events.ts:96:  return item as ThreadItem;
src/protocol/events.ts:121:  const message = parsed as ServerInboundMessage;
src/protocol/events.ts:139:  return message as Extract<ServerInboundMessage, { method: M }>;
src/protocol/events.ts:272:  const params = message.params as Record<string, unknown>;
src/protocol/events.ts:308:      ? (message.params as Record<string, unknown>)
src/protocol/events.ts:313:    const msg = params.msg as Record<string, unknown>;
src/protocol/events.ts:323:    ? (message.params as Record<string, unknown>)
src/protocol/events.ts:495:    ? (message.params as Record<string, unknown>)
src/protocol/events.ts:626:      ? (message.params as Record<string, unknown>)
src/protocol/events.ts:648:      ? (message.params as Record<string, unknown>)
src/protocol/parser.ts:25:  return typeof value === "object" && value !== null ? (value as Record<string, unknown>) : null;
src/protocol/parser.ts:33:  return validator.errors as AjvError[] | null | undefined;
src/host/tauri.ts:3:import type { LoginAccountParams as ProtocolLoginAccountParams } from "../protocol/schemas/v2/LoginAccountParams.js";
src/host/tauri.ts:212:  const parsed = JSON.parse(line) as { type?: unknown; payload?: unknown };
src/host/tauri.ts:216:  if (typeof parsed.type !== "string" || !HELPER_COMMAND_TYPE_SET.has(parsed.type as HelperCommandType)) {
src/host/tauri.ts:220:    return { type: parsed.type } as HelperCommand;
src/host/tauri.ts:225:  return parsed as HelperCommand;
src/host/convexSlice.ts:334:  const record = value as Record<string, unknown>;
src/host/convexSlice.ts:346:  const streamStats = (state as { streamStats?: unknown[] | null }).streamStats;
src/host/convexSlice.ts:354:  const recentMessages = (state as { recentMessages?: DurableHistoryMessage[] | null }).recentMessages;
src/host/convexSlice.ts:362:  const allStreams = (state as { allStreams?: Array<{ streamId: string }> | null }).allStreams;
src/protocol/events.ts:304:    ? (message.params as Record<string, unknown>)
src/protocol/events.ts:476:    ? (message.params as Record<string, unknown>)
src/protocol/events.ts:607:      ? (message.params as Record<string, unknown>)
src/protocol/events.ts:629:      ? (message.params as Record<string, unknown>)
src/protocol/parser.ts:21:  return typeof value === "object" && value !== null ? (value as Record<string, unknown>) : null;
src/protocol/parser.ts:29:  return validator.errors as AjvError[] | null | undefined;
